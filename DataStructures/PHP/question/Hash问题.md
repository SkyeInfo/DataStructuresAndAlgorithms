# 哈希
参考：  
[哈希函数的构造方法](https://www.cnblogs.com/gj-Acit/archive/2013/05/06/3062628.html)  

## 常用的构造散列函数的方法
**1.直接寻址法**  
直接定址法是以数据元素关键字k本身或它的线性函数作为它的哈希地址，即：H（k）=k  或 H（k）=a×k+b ； (其中a,b为常数)  
适合查找表较小且连续的情况  
优点：简单、均匀、不会产生冲突  
缺点：需要知道关键字的分布，现实中不常用  

**2.数字分析法**  
数字分析法是取数据元素关键字中某些取值较均匀的数字位作为哈希地址的方法。即当关键字的位数很多时，可以通过对关键字的各位进行分析，丢掉分布不均匀的位，作为哈希值。它只适合于所有关键字值已知的情况。通过分析分布情况把关键字取值区间转化为一个较小的关键字取值区间。

**3.平方取中法**  
先取关键字的平方，然后根据可使用空间的大小，选取平方数是中间几位为哈希地址。  

**4.折叠法** 
所谓折叠法是将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位），这方法称为折叠法。这种方法适用于关键字位数较多，而且关键字中每一位上数字分布大致均匀的情况。  

**5.除留余数法**  
取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址，即设定哈希函数为  Hash(key)=key mod p (p≤m)，其中，除数p称作模。  
除留余数法不仅可以对关键字直接取模，也可以在折叠、平方取中等运算后取模。对于除留余数法求哈希地址，关键在于模p的选择。使得数据元素集合中每一个关键字通过该哈希函数映射到内存单元的任意地址上的概率相等，从而尽可能减少发生哈希冲突的可能性。  
理论研究表明，除留余数法的模p取不大于表长且最接近表长m素数时效果最好，且p最好取1.1n～1.7n之间的一个素数（n为存在的数据元素个数）。

**6.伪随机数法**  
伪随机数法是将利用数据的键值经过随机数法的运算后的结果作为数据存储的位置。其公式如下（a和c为质数）：  
Y=（a * Key + c）mod 数组的大小

## 解决哈希冲突的常用方法
### 1.开放地址法
**线性探索法**  
在冲突位置以1步长依次向后探索，注意在删除元素时不能直接将对应位置置空，采用标记delete的方式软删除

**二次探测**  
在冲突位置依次以hash(key)+1^2, hash(key)+2^2, hash(key)+3^2...这样的步长向后探索

**双重散列**  
采用多个hash()方法，直到找到空闲位置

优点：  
记录更容易进行序列化（serialize）操作  
如果记录总数可以预知，可以创建完美哈希函数，此时处理数据的效率是非常高的  
 
缺点：  
存储记录的数目不能超过桶数组的长度，如果超过就需要扩容，而扩容会导致某次操作的时间成本飙升，这在实时或者交互式应用中可能会是一个严重的缺陷  
使用探测序列，有可能其计算的时间成本过高，导致哈希表的处理性能降低  
由于记录是存放在桶数组中的，而桶数组必然存在空槽，所以当记录本身尺寸（size）很大并且记录总数规模很大时，空槽占用的空间会导致明显的内存浪费  
删除记录时，比较麻烦。比如需要删除记录a，记录b是在a之后插入桶数组的，但是和记录a有冲突，是通过探测序列再次跳转找到的地址，所以如果直接删除a，a的位置变为空槽，而空槽是查询记录失败的终止条件，这样会导致记录b在a的位置重新插入数据前不可见，所以不能直接删除a，而是设置删除标记。这就需要额外的空间和操作。

### 拉链法
这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。  

优点：  
对于记录总数频繁可变的情况，处理的比较好（也就是避免了动态调整的开销）  
由于记录存储在结点中，而结点是动态分配，不会造成内存的浪费，所以尤其适合那种记录本身尺寸（size）很大的情况，因为此时指针的开销可以忽略不计了  
删除记录时，比较方便，直接通过指针操作即可  
 
缺点：  
存储的记录是随机分布在内存中的，这样在查询记录时，相比结构紧凑的数据类型（比如数组），哈希表的跳转访问会带来额外的时间开销  
如果所有的 key-value 对是可以提前预知，并之后不会发生变化时（即不允许插入和删除），可以人为创建一个不会产生冲突的完美哈希函数，此时封闭散列的性能将远高于开放散列  
由于使用指针，记录不容易进行序列化（serialize）操作  

### 建立公共溢出区
这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。  
